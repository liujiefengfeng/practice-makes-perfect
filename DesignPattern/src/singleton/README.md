### 应用场景
避免资源访问冲突、表示业务概念上的全局唯一类
单例模式创建的对象是进程唯一的（单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的）

### 单例模式注意点
- 构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；
- 考虑对象创建时的线程安全问题；
- 考虑是否支持延迟加载；
- 考虑getInstance()性能是否高（是否加锁）。

### 实现方式
- 饿汉式 globalUnique
  ```
  在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到IdGenerator的时候，再创建实例）
  有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。
  如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。
  如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。
  ```
  
- 懒汉式 globalUnique.IdGeneratorLazy
  ```
  支持延迟加载。
  不过懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。
  ```
  
- 双重检测
  ```
  饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。
  
  ``` 

- 静态内部类
  ```
  比双重检测更加简单的实现方法，那就是利用Java的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。
  SingletonHolder 是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。
  ```
- 枚举
  ```
  这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性
  ```

### 问题
- 对OOP特性的支持不友好（封装，抽象，继承，多态）
- 隐藏类之间的依赖关系
- 对代码扩展性不友好
- 对代码可测试性不友好
- 不支持有参数的构造函数

### 思考
- 单例模式的作用范围
- 线程唯一的单例模式
- 集群唯一的单例模式
- 多例模式的理解
